synchronized
==

# 偏向锁

##  

因为偏向锁，锁住对象时，会写入对象头相应的标识，我们先把对象头(官方叫法为:Mark Word)的图示如下(借用了网友的图片):
   通过上面的图片，我们可以知道，对象处于偏向锁时,mark word中的偏向锁标记为1,锁标志位为01;下面是分析过jvm源码(biasedLocking.cpp)解析的偏向锁升级流程(忽略一些细节)，示例中:线程1当前拥有偏向锁对象,线程2是需要竞争到偏向锁。

1.线程2来竞争锁对象;
1.判断当前对象头是否是偏向锁;
1.判断拥有偏向锁的线程1是否还存在;
1.线程1不存在,直接设置偏向锁标识为0(线程1执行完毕后,不会主动去释放偏向锁);
1.使用cas替换偏向锁线程ID为线程2,锁不升级，仍为偏向锁;
1.线程1仍然存在,暂停线程1；
1.设置锁标志位为00(变为轻量级锁),偏向锁为0;
1.从线程1的空闲monitor record中读取一条,放至线程1的当前monitor record中;
1.更新mark word，将mark word指向线程1中monitor record的指针;
1.继续执行线程1的代码;
1.锁升级为轻量级锁;   
1.线程2自旋来获取锁对象;
  上面仍有一个问题，即如何判断线程1已经不存在了?
       仍然是分析完jvm源码(thread.cpp)后,得到的如下结论:
          (1) 线程执行start时，会将自己写入一个thread_list中,这是一个linked结构，有pre和next节点;

# 轻量级锁

# 重量级锁
