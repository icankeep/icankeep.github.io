# 知识点复习
- Spring源码深度解析
    - 加载bean步骤
    - 几个bean循环依赖如何解决
- Redis
    - 哨兵、集群
    - 数据类型
    - 跳表实现
    - 分布式锁
- 网络
    - 三次握手
    - 四次挥手
    - 七层和四层模型
    - 拥塞控制，窗口滑动
- 数据库
    - SQL语句
    - 存储引擎
    - 索引
    - 事务
    - 锁
    - 优化
- 虚拟机
    - 内存分布
    - 垃圾收集
    - 判断对象死亡
    - 对象的逃生机会
    - 频繁FullGc分析步骤
    - 分析虚拟机工具、命令
    - 不影响虚拟机性能情况分析内存？
    - 双亲委派模型
- Java基础
    - 并发包
    - 集合包
- 基础框架
    - Spring
    - Spring Boot
    - Spring MVC
    - MyBatis
- 基础算法
    - 排序
    - 搜索
        - 二分查找
        - 深度优先搜索
        - 广度优先搜索
    - 数据结构
- 设计模式
    - 单例模式
    - 代理模式
    - 工厂方法模式
    - 模板方法模式
    - 享元模式（Integer缓存池-128至127）
- 操作系统
    - 死锁（检测方法，避免方法，概念）
- 分布式
    - Zookeeper
        - 分布式锁实现
    - Spring Cloud
- 虚拟化
    - Linux
    - Docker


## java.util包下
1. WeakHashMap
    - 新建WeakHashMap，将“键值对”添加到WeakHashMap中。实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。
    - 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到ReferenceQueue(queue)队列中。
    - 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的键值对；同步它们，就是删除table中被GC回收的键值对。

    这就是“弱键”如何被自动从WeakHashMap中删除的步骤了。和HashMap一样，WeakHashMap是不同步的。可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap

    既然有WeakHashMap，那么有WeakHashSet吗？  java collections包是没有直接提供WeakHashSet的。

    我们可以通过Collections.newSetFromMap(Map<E,Boolean> map)方法可以将任何 Map包装成一个Set。

1. Vector和ArrayList
1. ArrayList和LinkedList
1. UUID
1. TreeMap、TreeSet
1. TimSort
1. Stack、ArrayDeque、LinkedList
1. PriorityQueue重写比较器
1. LinkedHashMap、LinkedHashSet
1. [IdentityHashMap](https://blog.csdn.net/f641385712/article/details/81880711)
    - 比如对于要保存的key，k1和k2，当且仅当k1== k2的时候，IdentityHashMap才会相等，而对于HashMap来说，相等的条件则是：对比两个key的hashCode相等
    - IdentityHashMap不是Map的通用实现，它有意违反了Map的常规协定。并且IdentityHashMap允许key和value都为null。
    - 同HashMap，IdentityHashMap也是无序的，并且该类不是线程安全的，如果要使之线程安全，可以调用Collections.synchronizedMap(new IdentityHashMap(…))方法来实现。
1. Hashtable和HashMap

## java.util.concurrent.atomic包下
1. AtomicInteger、AtomicLong、AtomicReference、AtomicBoolean
    AtomicInterger、AtomicLong底层实现sun.misc.Unsafe，AtomicBoolean将值转为int值再进行操作
1. AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray
    相比较于上面三个，多传了一个索引值参数
1. AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater
    修改某个对象中的某个字段
1. AtomicStampedReference
    - 通过volatile和Unsafe提供的CAS函数实现原子操作。 自旋+CAS的无锁操作保证共享变量的线程安全
    - value是volatile类型，这保证了：当某线程修改value的值时，其他线程看到的value的值都是最新的值，即修改之后的volatile的值
    - 通过CAS设置value。这保证了：某线程池通过CAS函数（如compareAndSet函数）设置value时，它的操作时原子性的，即线程在操作vu略时不会被中断。
    - 但是CAS操作可能存在ABA问题。AtomicStampedReference的出现就是为了解决这问题
    - 内部添加了Pair静态内部类，封装了reference和时间戳，CAS设置值时除了比较reference还要比较时间戳是否和预期的相同
1. AtomicMarkableReference
    - 和AtomicStampedReference差不多，Pair封装了reference和boolean mark值，只有当reference、mark满足预期才会修改

## java.util.concurrent.lock包下
1. AbstractQueuedSynchronizer、AbstractQueuedLongSynchronizer、AbstractOwnableSynchronizer
1. Condition
1. Lock、ReentrantLock、ReadWriteLock、ReentrantReadWriteLock
1. StampedLock
    StampedLock的主要特点概括一下，有以下几点：
    1. 所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功；
    1. 所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；
    1. StampedLock是不可重入的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）
    1. StampedLock有三种访问模式：
        - Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似
        - Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似
        - Optimistic reading（乐观读模式）：这是一种优化的读模式。
        StampedLock支持读锁和写锁的相互转换
    1. 我们知道RRW中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的。
    1. StampedLock提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。
    1. 无论写锁还是读锁，都不支持Conditon等待
    > 我们知道，在ReentrantReadWriteLock中，当读锁被使用时，如果有线程尝试获取写锁，该写线程会阻塞。
    > 但是，在Optimistic reading中，即使读线程获取到了读锁，写线程尝试获取写锁也不会阻塞，这相当于对读模式的优化，但是可能会导致数据不一致的问题。所以，当使用Optimistic reading获取到读锁时，> 必须对获取结果进行校验。
1. LockSupport
    Lock工具类，提供park,unpark,parkNanos,parkUtil等方法

## java.util.concurrent包下
Excutor --> ExcutorService --> AbstractExecutorService --> ForkJoinPool
1. ArrayBlockingQueue、DelayQueue、SynchronousQueue、LinkedBlockingQueue、LinkedBlockingDeque、LinkedTransferQueue、PriorityBlockingQueue
1. CopyOnWriteArrayList、CopyOnWriteArraySet
    1. 实现了List接口
    1. 内部持有一个ReentrantLock lock = new ReentrantLock();
    1. 底层是用volatile transient声明的数组 array
    1. 读写分离，写时复制出一个新的数组,长度加1，完成插入、修改或者移除操作后将新数组赋值给array
    1. 我知道Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。
1. ConcurrentSkipListMap、ConcurrentSkipListSet
    跳表（SkipList）是一种随机化的数据结构，通过“空间来换取时间”的一个算法，建立多级索引，实现以二分查找遍历一个有序链表。时间复杂度等同于红黑树，O(log n)。但实现却远远比红黑树要简单
1. Callable和Runnable
    - Callable接口重写call方法，可以带结果返回值
    - Runnable接口重写run方法，不带返回值
1. ConcurrentHashMap和HashMap
1. CountDownLatch、CyclicBarrier、Semaphore
1. ThreadPoolExecutor
1. Exchanger  
    实现线程间变量交换
1. Excutors
    - 包装Runnable对象为Callable
    - newFixedThreadPool、newCachedThreadPool、newScheduledThreadPool、newSingleThreadExecutor
 ForkJoin Future Object

