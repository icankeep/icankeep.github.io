# 知识点复习
- Spring源码深度解析
    - 加载bean步骤
    - 几个bean循环依赖如何解决
- Redis
    - 哨兵、集群
    - 数据类型
    - 跳表实现
    - 分布式锁
    - 主从复制
- 网络
    - [三次握手](#三次握手)
    - [四次挥手](#四次挥手)
    - 七层和四层模型
    - 拥塞控制
    - 窗口滑动
    - [tcp、udp区别](#tcp、udp区别)
    - [http、https区别](#客户端使用https通信流程)
- 数据库
    - SQL语句
        - JOIN、LEFT JOIN、RIGHT JOIN、INNER JOIN
        - UNION、UNION ALL（UNION排序去重，UNION ALL则不会）
    - [存储引擎](https://icankeep.github.io/posts/2019/03/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/)
    - [索引](https://icankeep.github.io/posts/2019/03/MySQL%E4%B8%AD%E7%B4%A2%E5%BC%95/)
        - B树和B+树的区别
        - 为什么数据库底层用B+树不用红黑树
    - [锁及事务](https://icankeep.github.io/posts/2019/03/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/)
    - 优化、分析慢查询，explain命令和trace命令
- 虚拟机
    - 内存分布
        - 程序计数器
        - 虚拟机栈
        - 本地方法栈
        - 堆
        - 方法区
    - 垃圾收集
        - 垃圾回收算法
        - 垃圾收集器
    - 判断对象死亡
        - 引用计数法（当对象相互引用时无法回收）
        - 可达性分析算法（从root对象处用深度优先算法）
    - 对象的逃生机会
    - 频繁FullGc分析步骤
    - 分析虚拟机工具、命令
    - 不影响虚拟机性能情况分析内存？
    - 双亲委派模型
- Java基础
    - 并发包
    - 集合包
- 基础框架
    - Spring
    - Spring Boot
    - Spring MVC
    - MyBatis
- 基础算法
    - 排序（平均时间复杂度，最坏时间复杂度，空间复杂度）
        - 快速排序（三向切分快速排序在数据重复情况较多的时候效率远高于双向切分）
        - 归并排序
        - 插入排序（希尔排序）
        - 堆排序
    - 搜索
        - 二分查找
        - 深度优先搜索
        - 广度优先搜索
    - 数据结构
- 设计模式
    - 单例模式
        - 双重检查锁定实现
        - 枚举类实现
    - 代理模式
        - 什么是代理
        - 动态代理和静态代理区别
    - 工厂方法模式
    - 模板方法模式
        - 哪些实例，父类留着空方法，子类实现，例如LinkedHashMap
    - 享元模式（池技术，Integer缓存池-128至127，线程池，字符串常量池，数据库连接池）
        - 享元模式：运用共享技术有效地支持大量细粒度对象的复用。享元模式是一种结构型设计模式，当一个系统中出现了大量相同或者相似的细粒度对象的时候。细粒度就是小对象，属性少方法少的对象。就可以可以考虑使用享元模式来就行系统的设计。享元模式就是通过共享这些细小的对象进行重用，像JAVA中的string字符的不变性其实就是享元模式的应用！并且享元模式的两个核心点就是享元池，和享元工厂。
- 操作系统
    - 死锁（检测方法，避免方法，概念）
- 分布式
    - Zookeeper
        - 分布式锁实现
    - Spring Cloud
- 虚拟化
    - Linux
    - Docker

## 三次握手
 TCP建立连接要进行3次握手
1. 主机A通过向主机B 发送一个含有同步序列号(SYN)的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我
1. 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:我已经收到你的请求了,你可以传输数据了;你要用序列号作为起始数据段来回应我
1. 主机A收到这个数据段后,再发送一个确认应答(ACK),确认已收到主机B 的数据段:"我已收到回复,我现在要开始传输实际数据了

3次握手就完成了,主机A和主机B 就可以传输数据，3次握手的特点:
- 没有应用层的数据
- SYN这个标志位只有在TCP建产连接时才会被置1
- 握手完成后SYN标志位被置0

 名词解释
1. ACK  TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性.
1. SYN  同步序列号,TCP建立连接时将这个位置1
1. FIN  发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1

## 四次挥手
1. 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求
1. 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
1. 由B 端再提出反方向的关闭请求,将FIN置1
1. 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.
由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端
和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础



## tcp、udp区别
TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立，其中的过程非常复杂，过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。
   
TCP断开连接要进行4次
1. 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求
1. 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
1. 由B 端再提出反方向的关闭请求,将FIN置1
1. 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.
由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端
和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础

区别
1. 基于连接与无连接；
1. 对系统资源的要求（TCP较多，UDP少）；
1. UDP程序结构较简单；
1. 流模式与数据报模式 ；
1. TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

## http、https区别
简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。
1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
1. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
1. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
1. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## 客户端使用https通信流程
客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤
1. 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
1. Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
1. 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
1. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
1. Web服务器利用自己的私钥解密出会话密钥。
1. Web服务器利用会话密钥加密与客户端之间的通信。

## java.util包下
1. WeakHashMap
    - 新建WeakHashMap，将“键值对”添加到WeakHashMap中。实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。
    - 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到ReferenceQueue(queue)队列中。
    - 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的键值对；同步它们，就是删除table中被GC回收的键值对。

    这就是“弱键”如何被自动从WeakHashMap中删除的步骤了。和HashMap一样，WeakHashMap是不同步的。可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap

    既然有WeakHashMap，那么有WeakHashSet吗？  java collections包是没有直接提供WeakHashSet的。

    我们可以通过Collections.newSetFromMap(Map<E,Boolean> map)方法可以将任何 Map包装成一个Set。

1. Vector和ArrayList
1. ArrayList和LinkedList
1. UUID
1. TreeMap、TreeSet
1. TimSort
1. Stack、ArrayDeque、LinkedList
1. PriorityQueue重写比较器
1. LinkedHashMap、LinkedHashSet
1. [IdentityHashMap](https://blog.csdn.net/f641385712/article/details/81880711)
    - 比如对于要保存的key，k1和k2，当且仅当k1== k2的时候，IdentityHashMap才会相等，而对于HashMap来说，相等的条件则是：对比两个key的hashCode相等
    - IdentityHashMap不是Map的通用实现，它有意违反了Map的常规协定。并且IdentityHashMap允许key和value都为null。
    - 同HashMap，IdentityHashMap也是无序的，并且该类不是线程安全的，如果要使之线程安全，可以调用Collections.synchronizedMap(new IdentityHashMap(…))方法来实现。
1. Hashtable和HashMap

## java.util.concurrent.atomic包下
1. AtomicInteger、AtomicLong、AtomicReference、AtomicBoolean
    AtomicInterger、AtomicLong底层实现sun.misc.Unsafe，AtomicBoolean将值转为int值再进行操作
1. AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray
    相比较于上面三个，多传了一个索引值参数
1. AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater
    修改某个对象中的某个字段
1. AtomicStampedReference
    - 通过volatile和Unsafe提供的CAS函数实现原子操作。 自旋+CAS的无锁操作保证共享变量的线程安全
    - value是volatile类型，这保证了：当某线程修改value的值时，其他线程看到的value的值都是最新的值，即修改之后的volatile的值
    - 通过CAS设置value。这保证了：某线程池通过CAS函数（如compareAndSet函数）设置value时，它的操作时原子性的，即线程在操作vu略时不会被中断。
    - 但是CAS操作可能存在ABA问题。AtomicStampedReference的出现就是为了解决这问题
    - 内部添加了Pair静态内部类，封装了reference和时间戳，CAS设置值时除了比较reference还要比较时间戳是否和预期的相同
1. AtomicMarkableReference
    - 和AtomicStampedReference差不多，Pair封装了reference和boolean mark值，只有当reference、mark满足预期才会修改

## java.util.concurrent.lock包下
1. AbstractQueuedSynchronizer、AbstractQueuedLongSynchronizer、AbstractOwnableSynchronizer
1. Condition
1. Lock、ReentrantLock、ReadWriteLock、ReentrantReadWriteLock
1. StampedLock
    StampedLock的主要特点概括一下，有以下几点：
    1. 所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功；
    1. 所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；
    1. StampedLock是不可重入的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）
    1. StampedLock有三种访问模式：
        - Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似
        - Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似
        - Optimistic reading（乐观读模式）：这是一种优化的读模式。
        StampedLock支持读锁和写锁的相互转换
    1. 我们知道RRW中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的。
    1. StampedLock提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。
    1. 无论写锁还是读锁，都不支持Conditon等待
    > 我们知道，在ReentrantReadWriteLock中，当读锁被使用时，如果有线程尝试获取写锁，该写线程会阻塞。
    > 但是，在Optimistic reading中，即使读线程获取到了读锁，写线程尝试获取写锁也不会阻塞，这相当于对读模式的优化，但是可能会导致数据不一致的问题。所以，当使用Optimistic reading获取到读锁时，> 必须对获取结果进行校验。
1. LockSupport
    Lock工具类，提供park,unpark,parkNanos,parkUtil等方法

## java.util.concurrent包下
Excutor --> ExcutorService --> AbstractExecutorService --> ForkJoinPool
1. ArrayBlockingQueue、DelayQueue、SynchronousQueue、LinkedBlockingQueue、LinkedBlockingDeque、LinkedTransferQueue、PriorityBlockingQueue
1. CopyOnWriteArrayList、CopyOnWriteArraySet
    1. 实现了List接口
    1. 内部持有一个ReentrantLock lock = new ReentrantLock();
    1. 底层是用volatile transient声明的数组 array
    1. 读写分离，写时复制出一个新的数组,长度加1，完成插入、修改或者移除操作后将新数组赋值给array
    1. 我知道Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。
1. ConcurrentSkipListMap、ConcurrentSkipListSet
    跳表（SkipList）是一种随机化的数据结构，通过“空间来换取时间”的一个算法，建立多级索引，实现以二分查找遍历一个有序链表。时间复杂度等同于红黑树，O(log n)。但实现却远远比红黑树要简单
1. Callable和Runnable
    - Callable接口重写call方法，可以带结果返回值
    - Runnable接口重写run方法，不带返回值
1. ConcurrentHashMap和HashMap
1. CountDownLatch、CyclicBarrier、Semaphore
1. ThreadPoolExecutor
1. Exchanger  
    实现线程间变量交换
1. Excutors
    - 包装Runnable对象为Callable
    - newFixedThreadPool、newCachedThreadPool、newScheduledThreadPool、newSingleThreadExecutor


 ForkJoin Future Object

